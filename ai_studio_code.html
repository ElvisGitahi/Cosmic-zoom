<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }

        /* UI Panel */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            z-index: 100;
            width: 220px;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; font-weight: 300; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 12px; margin-bottom: 5px; opacity: 0.8; }
        
        select, input[type="color"] {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
        }

        .status { font-size: 11px; margin-top: 10px; color: #00ffcc; }
        
        /* Hidden video for tracking */
        #video-input { display: none; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <h2>PARTICLE CORE</h2>
        <div class="control-group">
            <label>TEMPLATE</label>
            <select id="template-select">
                <option value="heart">Heart Shape</option>
                <option value="flower">Cosmic Flower</option>
                <option value="saturn">Saturn Rings</option>
                <option value="fireworks">Fireworks</option>
            </select>
        </div>
        <div class="control-group">
            <label>PARTICLE COLOR</label>
            <input type="color" id="color-picker" value="#00ffff">
        </div>
        <div class="status" id="tracking-status">Waiting for camera...</div>
        <div style="font-size: 10px; opacity: 0.5; margin-top: 10px;">
            Open hand to expand. <br> Close fist to contract.
        </div>
    </div>

    <video id="video-input"></video>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- Configuration ---
        const PARTICLE_COUNT = 8000;
        let currentTemplate = 'heart';
        let particleColor = 0x00ffff;
        let handTension = 0; // 0 = closed, 1 = open
        let handPos = { x: 0, y: 0, z: 0 };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 5;

        // --- Particle Geometry ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const velocities = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 10;
            velocities[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
            size: 0.015,
            color: particleColor,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- Shapes Mathematical Generators ---
        function updateTargets() {
            const arr = targetPositions;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                const t = Math.random() * Math.PI * 2;
                const u = Math.random() * Math.PI * 2;

                if (currentTemplate === 'heart') {
                    // Parametric Heart
                    x = 1.6 * Math.pow(Math.sin(t), 3);
                    y = 1.3 * Math.cos(t) - 0.5 * Math.cos(2*t) - 0.2 * Math.cos(3*t) - 0.1 * Math.cos(4*t);
                    z = (Math.random() - 0.5) * 0.5;
                } 
                else if (currentTemplate === 'flower') {
                    // Rose Curve / Flower
                    const k = 5; 
                    const r = 2 * Math.cos(k * t);
                    x = r * Math.cos(t);
                    y = r * Math.sin(t);
                    z = (Math.random() - 0.5) * 0.5;
                } 
                else if (currentTemplate === 'saturn') {
                    if (i < PARTICLE_COUNT * 0.3) {
                        // The Planet
                        const r = 0.8;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const theta = Math.random() * Math.PI * 2;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else {
                        // The Rings
                        const r = 1.5 + Math.random() * 1.0;
                        x = r * Math.cos(t);
                        y = r * Math.sin(t) * 0.2; // Tilt
                        z = r * Math.sin(t);
                    }
                } 
                else if (currentTemplate === 'fireworks') {
                    const r = Math.random() * 2.5;
                    x = r * Math.sin(t) * Math.cos(u);
                    y = r * Math.sin(t) * Math.sin(u);
                    z = r * Math.cos(t);
                }

                arr[i * 3] = x;
                arr[i * 3 + 1] = y;
                arr[i * 3 + 2] = z;
            }
        }

        updateTargets();

        // --- MediaPipe Hand Tracking ---
        const videoElement = document.getElementById('video-input');
        const statusLabel = document.getElementById('tracking-status');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusLabel.innerText = "Tracking Active";
                const landmarks = results.multiHandLandmarks[0];
                
                // Hand Position (Index finger tip as anchor)
                // Map 0-1 range to Three.js coordinates
                handPos.x = (landmarks[9].x - 0.5) * -10; 
                handPos.y = (landmarks[9].y - 0.5) * -10;

                // Hand Tension (Distance between wrist and middle finger tip)
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const dx = wrist.x - middleTip.x;
                const dy = wrist.y - middleTip.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // Normalize tension (approx 0.1 for fist, 0.4 for open palm)
                handTension = THREE.MathUtils.clamp((distance - 0.1) / 0.3, 0.1, 3.0);
            } else {
                statusLabel.innerText = "Hand not detected";
                handTension = 1.0; // Reset to default
            }
        });

        const cameraStream = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraStream.start();

        // --- Interaction Logic ---
        document.getElementById('template-select').addEventListener('change', (e) => {
            currentTemplate = e.target.value;
            updateTargets();
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            particleSystem.material.color.set(e.target.value);
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = geometry.attributes.position.array;
            const target = targetPositions;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;

                // Target position modified by hand tension (expansion)
                const tx = (target[idx] * handTension) + handPos.x;
                const ty = (target[idx + 1] * handTension) + handPos.y;
                const tz = target[idx + 2] * handTension;

                // Smoothly lerp particles to target
                positions[idx] += (tx - positions[idx]) * 0.1;
                positions[idx + 1] += (ty - positions[idx + 1]) * 0.1;
                positions[idx + 2] += (tz - positions[idx + 2]) * 0.1;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // Subtle rotation
            particleSystem.rotation.y += 0.002;
            particleSystem.rotation.x += 0.001;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>